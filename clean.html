<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ø£Ø¯Ø§Ø© ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§Øª â€” Hantera TV</title>
  <style>
    body { font-family: Inter, system-ui, sans-serif; background:#0f172a; color:#e6eef8; padding:20px; }
    .card { background:#0b1220; border-radius:12px; padding:16px; box-shadow:0 6px 18px rgba(2,6,23,0.6); }
    button { background:#06b6d4; color:#012; border:0; padding:10px 14px; border-radius:10px; cursor:pointer; }
    button.warn { background:#f97316; color:#fff; }
    pre { white-space:pre-wrap; word-wrap:break-word; max-height:48vh; overflow:auto; background:#071024; padding:12px; border-radius:8px; }
    .controls { display:flex; gap:8px; align-items:center; margin-bottom:12px; }
    label { font-size:14px; }
    input[type=checkbox] { width:18px; height:18px; }
    .stats { display:flex; gap:12px; margin-top:8px; font-size:13px; color:#9fb7cb; }
  </style>
</head>
<body>
  <div class="card" style="max-width:980px;margin:0 auto;">
    <h1 style="margin:0 0 8px 0;">ğŸ§¹ Ø£Ø¯Ø§Ø© ØªÙ†Ø¸ÙŠÙ Ø³ÙŠØ±ÙØ±Ø§Øª Ø§Ù„Ø¨Ø« (Matches â†’ streams)</h1>
    <p style="margin:0 0 12px 0;color:#9fb7cb">ØªØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„ Ù…Ø¨Ø§Ø±Ø§Ø© ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© <code>matches</code> ÙˆØªÙØ²ÙŠÙ„ Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø§Ù„Ù€ <code>streams</code> Ù„Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©. ØªØ¹Ù…Ù„ Ù…Ù† Ø§Ù„Ù…ØªØµÙØ­.</p>

    <div class="controls">
      <button id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªÙ†Ø¸ÙŠÙ</button>
      <button id="clearLog" class="warn">Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØº</button>
      <label><input type="checkbox" id="dryRun" checked /> ØªØ¬Ø±Ø¨Ø© ÙÙ‚Ø· (dry-run)</label>
      <label><input type="checkbox" id="delMatchIfEmpty" /> Ø­Ø°Ù Ù…Ø³ØªÙ†Ø¯ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ùˆ Ø¨Ù‚Ù‰ Ø¨Ø¯ÙˆÙ† streams</label>
    </div>

    <div class="stats" id="stats">
      <div>Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ù…ÙØ­ÙˆØµØ©: <strong id="checked">0</strong></div>
      <div>Ø³ÙŠØ±ÙØ±Ø§Øª Ù…Ø­Ø°ÙˆÙØ©: <strong id="deleted">0</strong></div>
      <div>Ø£Ø®Ø·Ø§Ø¡: <strong id="errors">0</strong></div>
    </div>

    <h3 style="margin-top:12px">Ù„ÙˆØº Ø§Ù„ØªÙ†ÙÙŠØ°</h3>
    <pre id="log">Ø¬Ø§Ù‡Ø². Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªÙ†Ø¸ÙŠÙ".</pre>

    <p style="margin-top:12px;color:#8aa6bf;font-size:13px">
      Ù…Ù„Ø§Ø­Ø¸Ø©: Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ù‚ÙˆØ§Ø¹Ø¯ Firestore ØªÙ…Ù†Ø¹ Ø§Ù„Ø­Ø°Ù Ù…Ù† Ù…ØªØµÙØ­ÙƒØŒ Ø§Ø³ØªØ®Ø¯Ù… Cloud Function Ù…Ø¹ Admin SDK Ø£Ùˆ Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ù…Ø¤Ù‚ØªØ§Ù‹ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±.
    </p>
  </div>

<script type="module">
  // --------------- ØªÙƒÙˆÙŠÙ† Firebase (Ù…Ù† Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ Ø§Ù„Ù„ÙŠ Ø´Ø§Ø±ÙƒØªÙ‡) ----------------
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import {
    getFirestore, collection, getDocs, doc, getDoc, deleteDoc, query, where, limit
  } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB6ACvhgth3VXhoJJnNOZfIQBpXlTVWcGE",
    authDomain: "website-f388d.firebaseapp.com",
    projectId: "website-f388d",
    storageBucket: "website-f388d.firebasestorage.app",
    messagingSenderId: "531820596793",
    appId: "1:531820596793:web:37dbfd0b9a3c7a3a0cc7e8",
    measurementId: "G-75KT28HL7H"
  };

  // init
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------------- UI elements ----------------
  const startBtn = document.getElementById('startBtn');
  const logEl = document.getElementById('log');
  const dryRunEl = document.getElementById('dryRun');
  const deletedEl = document.getElementById('deleted');
  const checkedEl = document.getElementById('checked');
  const errorsEl = document.getElementById('errors');
  const clearLogBtn = document.getElementById('clearLog');
  const delMatchIfEmptyEl = document.getElementById('delMatchIfEmpty');

  let stats = { checked:0, deleted:0, errors:0 };

  function log(...messages){
    const time = new Date().toLocaleTimeString();
    logEl.textContent = `[${time}] ` + messages.join(' ') + "\\n" + logEl.textContent;
  }
  function updateStats(){ checkedEl.textContent = stats.checked; deletedEl.textContent = stats.deleted; errorsEl.textContent = stats.errors; }

  clearLogBtn.onclick = () => { logEl.textContent = ''; };

  // ------------- logic config -------------
  const API_ENDPOINT = "https://ko.best-goal.live/state.php?match_id=";
  // Ø§Ù„Ø­ÙØ§Ø§Ù„Øª Ø§Ù„Ù„ÙŠ Ù†Ø¹ØªØ¨Ø±Ù‡Ø§ "Ø§Ù†ØªÙ‡Øª" Ø¨Ø§Ù„Ø¶Ø¨Ø· â€” Ø¹Ø¯Ù‘Ù„ Ù‡Ù†Ø§ Ù„Ùˆ Ø¹Ø§ÙŠØ² Ø­Ø§Ù„Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
  const FINISHED_STATUSES = new Set([
    "Ø¥Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©",
    "Ø¥Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© - Ø±ÙƒÙ„Ø§Øª Ø§Ù„ØªØ±Ø¬ÙŠØ­",
    "ended",
    "finished"
  ]);

  // rate limiter Ø¨Ø³ÙŠØ·: Ø¹Ø¯Ø¯ Ø·Ù„Ø¨Ø§Øª API Ù…ØªØ²Ø§Ù…Ù†Ø©
  const MAX_CONCURRENCY = 6;

  // ------------- helper: limited concurrency runner -------------
  async function pMap(inputs, mapper, concurrency = 4){
    const result = [];
    const executing = [];
    for (const item of inputs){
      const p = Promise.resolve().then(() => mapper(item));
      result.push(p);
      executing.push(p);
      if (executing.length >= concurrency){
        await Promise.race(executing).catch(()=>{}); // swallow so loop continues, errors counted inside mapper
        // remove resolved
        for (let i = executing.length-1; i>=0; i--){
          if (executing[i].settled) executing.splice(i,1);
        }
      }
    }
    return Promise.allSettled(result);
  }

  // mark settled helper
  function markSettled(p){
    p.then(()=>p.settled = true, ()=>p.settled = true);
    return p;
  }

  // ------------- main cleaning function -------------
  async function runCleanup(){
    startBtn.disabled = true;
    const isDry = dryRunEl.checked;
    const delMatchIfEmpty = delMatchIfEmptyEl.checked;
    log("Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙØ­Øµ. dry-run =", isDry ? "Ù†Ø¹Ù…" : "Ù„Ø§");

    try {
      const matchesCol = collection(db, "matches");
      const snapshot = await getDocs(matchesCol);
      if (snapshot.empty){
        log("Ù…Ø§ ÙÙŠØ´ Ù…Ø¨Ø§Ø±ÙŠØ§Øª ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© 'matches'. Ø¥ÙŠÙ‚Ø§Ù.");
        startBtn.disabled = false;
        return;
      }
      const docs = [];
      snapshot.forEach(d => docs.push({ id: d.id, ref: d.ref }));

      log("Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©:", docs.length);

      // process each match with limited concurrency
      const processMatch = async (m) => {
        stats.checked++; updateStats();
        const matchId = m.id;
        log("ÙØ­Øµ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©:", matchId);

        // call external API
        let statusText = null;
        try{
          const res = await fetch(API_ENDPOINT + encodeURIComponent(matchId), {cache:"no-store"});
          if (!res.ok){
            throw new Error("API response " + res.status);
          }
          const json = await res.json().catch(()=>null);
          // try a few possible fields
          statusText = json?.["Match-Status"] ?? json?.match_status ?? json?.status ?? null;
          // fallback: if API returns raw text:
          if (!statusText && typeof json === "string") statusText = json;
          log("  status for", matchId, "â†’", statusText ?? "(ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ)");
        }catch(err){
          stats.errors++; updateStats();
          log("  Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©", matchId, ":", err.message);
          return;
        }

        if (!statusText) return; // Ù„Ø§ Ù†Ø¹Ø±Ù Ø§Ù„Ø­Ø§Ù„Ø©

        if (!FINISHED_STATUSES.has(statusText.trim())){
          log("  Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ù… ØªÙ†ØªÙ‡Ù (ØªØ®Ø·Ù‰).");
          return;
        }

        // Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø§Ù†ØªÙ‡Øª â€” Ù†Ø­Ø°Ù Ø§Ù„Ù€ streams
        log("  Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù…ÙÙ†ØªÙ‡ÙŠØ© â†’ ØªÙ†Ø¸ÙŠÙ streams...");
        // Ø¬Ù„Ø¨ Ø§Ù„Ù€ streams subcollection
        try{
          const streamsColPath = `matches/${matchId}/streams`;
          // Ø§Ù„Ø­Ù„ Ø§Ù„Ø¨Ø³ÙŠØ·: Ù†ÙØ¹Ù„ getDocs Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø±
          const streamsSnapshot = await getDocs(collection(db, "matches", matchId, "streams"));
          if (streamsSnapshot.empty){
            log("    Ù„Ø§ ØªÙˆØ¬Ø¯ streams Ù„Ù„Ù…Ø¨Ø§Ø±Ø§Ø©:", matchId);
            if (delMatchIfEmpty && !isDry){
              log("    Ø­Ø°Ù Ù…Ø³ØªÙ†Ø¯ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ø£Ù†Ù‡ ÙØ§Ø±Øº Ù…Ù† streams:", matchId);
              await deleteDoc(doc(db, "matches", matchId));
            }
            return;
          }

          const deletes = [];
          streamsSnapshot.forEach(docSnap => {
            deletes.push({ id: docSnap.id, ref: docSnap.ref });
          });

          for (const s of deletes){
            if (isDry){
              log("    [dry] ÙƒØ§Ù† Ø­ÙŠØªÙ… Ø­Ø°Ù stream:", s.id);
            }else{
              try{
                await deleteDoc(s.ref);
                stats.deleted++; updateStats();
                log("    Ø­Ø°Ù stream:", s.id);
              }catch(e){
                stats.errors++; updateStats();
                log("    Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù stream", s.id, ":", e.message);
              }
            }
          }

          // Ø¨Ø¹Ø¯ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ù€ streamsØŒ Ù„Ùˆ Ø§Ø®ØªØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø­Ø°Ù Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ùˆ ÙØ§Ø¶ÙŠØ©
          if (!isDry && delMatchIfEmpty){
            // ØªØ­Ù‚Ù‚ Ø¥Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© ÙØ§Ø¶ÙŠØ©
            const after = await getDocs(collection(db, "matches", matchId, "streams"));
            if (after.empty){
              try {
                await deleteDoc(doc(db, "matches", matchId));
                log("    Ø­Ø°Ù Ù…Ø³ØªÙ†Ø¯ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø¨Ø¹Ø¯ ØªÙ†Ø¸ÙŠÙ streams:", matchId);
              } catch(e){
                stats.errors++; updateStats();
                log("    ÙØ´Ù„ Ø­Ø°Ù Ù…Ø³ØªÙ†Ø¯ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©:", e.message);
              }
            } else {
              log("    Ø¨Ø¹Ø¯ Ø§Ù„Ø­Ø°ÙØŒ Ù„Ø§ Ø²Ø§Ù„Øª Ù‡Ù†Ø§Ù„Ùƒ streams Ù„Ù… ØªÙØ­Ø°Ù (Ø±Ø¨Ù…Ø§ Ø¨Ø³Ø¨Ø¨ Ù‚ÙˆØ§Ø¹Ø¯/permissions).");
            }
          }

        }catch(e){
          stats.errors++; updateStats();
          log("  Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© streams:", e.message);
        }
      }; // end processMatch

      // use concurrency
      const mapper = (m) => markSettled(processMatch(m));
      const all = [];
      for (let i = 0; i < docs.length; i += MAX_CONCURRENCY){
        const chunk = docs.slice(i, i + MAX_CONCURRENCY).map(mapper);
        await Promise.all(chunk);
      }

      log("Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø¨Ø§Ø±ÙŠØª Ù…ÙØ­ÙˆØµØ©:", stats.checked, "Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø­Ø°ÙˆÙ:", stats.deleted, "Ø£Ø®Ø·Ø§Ø¡:", stats.errors);
    }catch(err){
      stats.errors++; updateStats();
      log("Ø®Ø·Ø£ Ø¹Ø§Ù…:", err.message);
    } finally {
      updateStats();
      startBtn.disabled = false;
    }
  }

  startBtn.onclick = runCleanup;

</script>
</body>
</html>
